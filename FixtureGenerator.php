<?php
/**
 * @link https://github.com/AnatolyRugalev
 * @copyright Copyright (c) AnatolyRugalev
 * @license https://tldrlegal.com/license/gnu-general-public-license-v3-(gpl-3)
 */
namespace understeam\fixture;

use Yii;
use yii\db\ActiveQuery;
use yii\db\ActiveRecord;
use yii\gii\CodeFile;
use yii\gii\Generator;
use yii\helpers\ArrayHelper;

/**
 * Implements main logic of fixture generation
 * @author Anatoly Rugalev
 * @link https://github.com/AnatolyRugalev
 */
class FixtureGenerator extends Generator
{

    const STRATEGY_APPEND = 'append'; // MERGE???
    const STRATEGY_REPLACE = 'replace';
    const STRATEGY_IGNORE = 'ignore';

    public $fixturesDataPath = '@tests/codeception/common/fixtures/data';

    public $modelClass;

    public $relationDepth = 1;

    public $generationDepth = 3;

    public $strategy = self::STRATEGY_APPEND;

    public $query;

    protected $fixtures = [];
    protected $relationNames;

    //TODO: extended ActiveQuery filtration

    public static function getStrategies()
    {
        return [
            self::STRATEGY_APPEND => 'Append new data into existing file',
            self::STRATEGY_REPLACE => 'Overwrite existing fixtures with new data',
            self::STRATEGY_IGNORE => 'Ignore existing files (not recommended)',
        ];
    }

    public function init()
    {
        $this->query = <<<PHP
/**
 * @var string \$modelClass
 */
\$query = \$modelClass::find();
\$query->limit(20)->offset(0);
return \$query;

PHP;

        parent::init();
    }

    public function rules()
    {
        return ArrayHelper::merge(parent::rules(), [
            [
                [
                    'modelClass',
                    'relationDepth',
                    'generationDepth',
                    'fixturesDataPath',
                    'strategy',
                    'query',
                ],
                'safe'
            ],
        ]);
    }

    //TODO: validation

    /**
     * @inheritdoc
     */
    public function getName()
    {
        return "Fixture Generator";
    }

    /**
     * @inheritdoc
     */
    public function getDescription()
    {
        return "Generates relational fixtures from database data";
    }

    /**
     * @inheritdoc
     */
    public function attributeLabels()
    {
        return ArrayHelper::merge(parent::attributeLabels(), [
            'modelClass' => 'Base model class',
            'relationDepth' => 'Maximum depth of relations',
            'generationDepth' => 'Maximum depth of relational data',
            'strategy' => 'Secondary fixtures overwrite strategy',
            'query' => 'PHP expression which generates ActiveQuery object',
        ]);
    }

    /**
     * @inheritdoc
     */
    public function hints()
    {
        return ArrayHelper::merge(parent::hints(), [
            'modelClass' => 'Class name of base model',
            'strategy' => 'Merging strategy of existing fixtures',
            'query' => 'You can use $modelClass variable in this expression',
        ]);
    }

    /**
     * @inheritdoc
     */
    public function generate()
    {
        /** @var ActiveRecord $modelClass */
        $modelClass = $this->modelClass;
        $models = $this->findBaseData();
        $this->generateFixtures($modelClass, $models);
        return $this->renderFixtures();
    }

    public function renderFixtures()
    {
        $files = [];
        foreach ($this->fixtures as $modelClass => $data) {
            /** @var $modelClass ActiveRecord */
            $tableName = $modelClass::tableName();
            if (preg_match('#\{\{%([^\}]+)\}\}#', $tableName, $matches)) {
                $name = $matches[1];
            } else {
                $name = $tableName;
            }
            $files[] = new CodeFile(Yii::getAlias($this->fixturesDataPath . '/' . $name . '.php'), $this->renderData($modelClass, $name, $data));
        }
        return $files;
    }

    public function renderData($modelClass, $name, $data)
    {
        $text = <<<TEXT
<?php
// Class: {$modelClass}

/**
 * Fixture generated by understeam/yii2-fixture-generator
 */

return
TEXT;

        $existingData = [];
        if ($this->strategy == self::STRATEGY_APPEND || $this->strategy == self::STRATEGY_IGNORE) {
            $fixtureFile = Yii::getAlias($this->fixturesDataPath . '/' . $name . '.php');
            if (is_file($fixtureFile)) {
                /** @noinspection PhpIncludeInspection */
                $existingData = require($fixtureFile);
            }
        }
        if ($this->strategy == self::STRATEGY_APPEND) {
            $data = ArrayHelper::merge($existingData, $data);
        } elseif ($this->strategy == self::STRATEGY_IGNORE) {
            $data = $existingData;
        }

        return $text . " " . self::varExportShort($data) . ";\n";
    }

    /**
     * Method makes array rendering with short PHP 5.4 syntax
     * @param $var
     * @return string
     */
    public static function varExportShort($var, $indent = "")
    {
        switch (gettype($var)) {
            case "array":
                $str = "[";
                if (count($var)) {
                    $str .= "\n";
                }
                foreach ($var as $key => $val) {
                    $str .= $indent . "    ";
                    $str .= var_export($key, true);
                    $str .= " => ";
                    $str .= self::varExportShort($val, $indent . "    ") . ",\n";
                }
                $str .= $indent . "]";
                return $str;
            case 'NULL':
                return 'null';
            default:
                return var_export($var, true);
        }
    }

    public function generateFixtures($modelClass, $models, $depth = 1)
    {
        $modelClass = ltrim($modelClass, '\\');
        if ($depth > $this->generationDepth) {
            return;
        }
        if (!isset($this->fixtures[$modelClass])) {
            $this->fixtures[$modelClass] = [];
        }
        $this->fixtures[$modelClass] = ArrayHelper::merge($this->fixtures[$modelClass], $this->getFixtureByModels($models));
        foreach ($models as $model) {
            $relations = $this->getModelRelationNames($model);
            foreach ($relations as $name => $config) {
                if ($config['multiple']) {
                    $this->generateFixtures($config['modelClass'], $model->{$name}, $depth + 1);
                } else {
                    $related = $model->{$name};
                    if ($related == null) {
                        $this->generateFixtures($config['modelClass'], [], $depth + 1);
                    } else {
                        $this->generateFixtures($config['modelClass'], [$related], $depth + 1);
                    }
                }
            }
        }
    }

    public function getModelRelationNames(ActiveRecord $model)
    {
        $modelClass = get_class($model);
        if (!isset($this->relationNames)) {
            if ($this->relationDepth > 0) {
                $this->buildRelationNames($this->modelClass);
            } else {
                $this->relationNames = [];
            }
        }
        return isset($this->relationNames[$modelClass]) ? $this->relationNames[$modelClass] : [];
    }

    public function buildRelationNames($modelClass, $depth = 1)
    {
        /**
         * Find all get* methods and detect return type
         */
        $model = new $modelClass;
        if (isset($this->relationNames[get_class($model)])) {
            return;
        }
        $reflection = new \ReflectionClass($model);
        $methods = $reflection->getMethods(\ReflectionMethod::IS_PUBLIC);
        $relationsToBuild = [];
        foreach ($methods as $method) {
            if (!$this->isRelation($method)) {
                continue;
            }
            /** @var ActiveQuery $relation */
            $relation = $model->{$method->name}();
            if (!$relation instanceof ActiveQuery) {
                continue;
            }
            $relationsToBuild[$relation->modelClass] = true;
            $this->addRelation(get_class($model), lcfirst(substr($method->name, 3)), $relation);
        }
        if ($depth < $this->relationDepth) {
            foreach ($relationsToBuild as $relationClass => $flag) {
                $this->buildRelationNames($relationClass, $depth + 1);
            }
        }
    }

    public function isRelation(\ReflectionMethod $method)
    {
        if ($method->isStatic()) {
            return false;
        }
        if ($method->getNumberOfParameters() > 0) {
            return false;
        }
        if ($method->getDeclaringClass()->name == 'yii\\base\\Object') {
            return false;
        }
        if ($method->getDeclaringClass()->name == 'yii\\base\\Component') {
            return false;
        }
        if ($method->getDeclaringClass()->name == 'yii\\base\\Model') {
            return false;
        }
        if ($method->getDeclaringClass()->name == 'yii\\db\\BaseActiveRecord') {
            return false;
        }
        if ($method->getDeclaringClass()->name == 'yii\\db\\ActiveRecord') {
            return false;
        }
        if (strpos($method->name, 'get') !== 0) {
            return false;
        }
        $methodCode = $this->getMethodCode($method);
        if (preg_match('#->has(One|Many)#', $methodCode)) {
            return true;
        }

        return false;
    }

    public function getMethodCode(\ReflectionMethod $method)
    {
        $startLine = $method->getStartLine();
        $endLine = $method->getEndLine();
        $file = $method->getFileName();
        $fh = fopen($file, 'r');
        for ($i = 0; $i < $startLine; $i++) {
            fgets($fh);
        }
        $data = '';
        for ($i = $startLine; $i <= $endLine; $i++) {
            $data .= "\n" . fgets($fh);
        }
        fclose($fh);

        return $data;
    }

    public function addRelation($baseClass, $relationName, ActiveQuery $relation)
    {
        if ($relation->via) {
            // We don't support via relations
            return;
        }
        if (!isset($this->relationNames[$baseClass])) {
            $this->relationNames[$baseClass] = [];
        }
        $this->relationNames[$baseClass][$relationName] = [
            'modelClass' => $relation->modelClass,
            'link' => $relation->link,
            'multiple' => $relation->multiple,
        ];
    }

    /**
     * TODO: description
     * @return ActiveRecord[]
     */
    public function findBaseData()
    {
        $query = $this->getActiveQuery();
        if(!$query) {
            return [];
        }
        return $query->all();
    }

    public function getActiveQuery()
    {
        /** @var ActiveRecord $modelClass */
        $modelClass = $this->modelClass;
        if($this->query) {
            try {
                $query = eval($this->query);
                return $query;
            } catch(\Exception $e) {
                throw $e;
            }
        }
        return $modelClass::find();
    }


    /**
     * TODO: description
     * @param ActiveRecord[] $models
     * @return array
     */
    public function getFixtureByModels($models)
    {
        $fixture = [];
        foreach ($models as $model) {
            if (is_array($model->primaryKey)) {
                $key = json_encode($model->primaryKey);
            } else {
                $key = $model->primaryKey;
            }
            $fixture['pk' . $key] = $model->getAttributes();
        }

        return $fixture;
    }
}
